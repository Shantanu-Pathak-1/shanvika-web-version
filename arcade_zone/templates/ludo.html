<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Ludo Battle â€¢ Arcade</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body { 
            background-color: #0b0f19; 
            color: white; 
            display: flex; flex-direction: column; align-items: center; justify-content: center; 
            height: 100vh; margin: 0; overflow: hidden; 
            font-family: 'Orbitron', sans-serif; 
            touch-action: none;
            background-image: radial-gradient(circle at center, #1e293b 0%, #0b0f19 100%);
        }

        .ludo-container {
            position: relative;
            width: 95vw;
            max-width: 380px;
            aspect-ratio: 1/1;
            background: #111827;
            border-radius: 15px;
            padding: 8px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.1), inset 0 0 20px rgba(255, 255, 255, 0.05);
            border: 2px solid #1e293b;
        }

        /* 15x15 Exact Ludo Grid */
        .ludo-grid {
            display: grid;
            grid-template-columns: repeat(15, 1fr);
            grid-template-rows: repeat(15, 1fr);
            width: 100%;
            height: 100%;
            gap: 2px;
            background: #1f2937;
            border-radius: 10px;
            overflow: hidden;
        }

        .cell {
            background: #0f172a;
            display: flex; align-items: center; justify-content: center;
            border-radius: 2px;
            position: relative;
        }

        /* Base Homes */
        .home-red { grid-column: 1 / 7; grid-row: 10 / 16; background: rgba(239, 68, 68, 0.1); border: 2px solid #ef4444; box-shadow: inset 0 0 20px rgba(239, 68, 68, 0.4), 0 0 10px rgba(239, 68, 68, 0.5); display: flex; align-items: center; justify-content: center; }
        .home-blue { grid-column: 10 / 16; grid-row: 1 / 7; background: rgba(59, 130, 246, 0.1); border: 2px solid #3b82f6; box-shadow: inset 0 0 20px rgba(59, 130, 246, 0.4), 0 0 10px rgba(59, 130, 246, 0.5); display: flex; align-items: center; justify-content: center; }
        
        /* Inactive Homes */
        .home-green { grid-column: 1 / 7; grid-row: 1 / 7; background: rgba(16, 185, 129, 0.05); border: 2px solid #064e3b; opacity: 0.5; }
        .home-yellow { grid-column: 10 / 16; grid-row: 10 / 16; background: rgba(245, 158, 11, 0.05); border: 2px solid #78350f; opacity: 0.5; }
        .center-home { grid-column: 7 / 10; grid-row: 7 / 10; background: radial-gradient(circle, #fff, #1e293b); box-shadow: 0 0 15px rgba(255,255,255,0.2); }

        .home-inner { width: 65%; height: 65%; background: #0b0f19; border-radius: 10px; display: grid; grid-template-columns: 1fr 1fr; gap: 8px; padding: 8px; border: 1px solid rgba(255,255,255,0.1); }
        .base-spot { width: 100%; height: 100%; border-radius: 50%; border: 2px dashed rgba(255,255,255,0.2); display: flex; align-items: center; justify-content: center; }

        /* Path Colors */
        .path-red { background: rgba(239, 68, 68, 0.2) !important; box-shadow: inset 0 0 10px rgba(239, 68, 68, 0.3); }
        .path-blue { background: rgba(59, 130, 246, 0.2) !important; box-shadow: inset 0 0 10px rgba(59, 130, 246, 0.3); }
        .safe-zone { font-size: 14px; color: #facc15; text-shadow: 0 0 5px #facc15; }
        .safe-zone::after { content: 'â˜…'; }

        /* Gotis (Tokens) */
        .goti { 
            width: 22px; height: 22px; 
            border-radius: 50%; position: absolute; 
            z-index: 50; transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); 
            transform: translate(-50%, -50%); cursor: pointer;
            border: 2px solid white;
        }
        .goti.red { background: radial-gradient(circle at 30% 30%, #ff7eb3, #ff0055); box-shadow: 0 0 15px #ff0055, 0 5px 10px rgba(0,0,0,0.5); }
        .goti.blue { background: radial-gradient(circle at 30% 30%, #7efff5, #00b8ff); box-shadow: 0 0 15px #00b8ff, 0 5px 10px rgba(0,0,0,0.5); }
        
        /* Animations */
        .goti.active-anim { animation: pulseGlow 1s infinite alternate; z-index: 100; cursor: pointer; }
        @keyframes pulseGlow { 0% { transform: translate(-50%, -50%) scale(1); box-shadow: 0 0 15px #fff; } 100% { transform: translate(-50%, -65%) scale(1.2); box-shadow: 0 0 30px #fff; } }

        /* Dice Area */
        .control-panel { width: 95vw; max-width: 380px; display: flex; justify-content: space-between; align-items: center; margin-top: 20px; background: rgba(30, 41, 59, 0.5); padding: 10px 20px; border-radius: 15px; border: 1px solid rgba(255,255,255,0.1); }
        .player-tag { text-align: center; font-weight: bold; font-size: 12px; transition: 0.3s; opacity: 0.5; padding: 5px 15px; border-radius: 8px; }
        .player-tag.active { opacity: 1; transform: scale(1.1); background: rgba(255,255,255,0.1); box-shadow: 0 0 15px rgba(255,255,255,0.1); }
        .player-red { color: #ff0055; text-shadow: 0 0 8px #ff0055; }
        .player-blue { color: #00b8ff; text-shadow: 0 0 8px #00b8ff; }
        
        .dice { 
            width: 50px; height: 50px; background: #fff; color: #0f172a; 
            font-size: 28px; font-weight: 900; display: flex; align-items: center; justify-content: center; 
            border-radius: 12px; cursor: pointer; box-shadow: 0 0 20px rgba(255,255,255,0.5);
            transition: 0.1s;
        }
        .dice:active { transform: scale(0.9); box-shadow: 0 0 10px rgba(255,255,255,0.3); }
        .dice.rolling { animation: shake 0.3s infinite; pointer-events: none; }
        @keyframes shake { 0% {transform: rotate(15deg);} 50% {transform: rotate(-15deg);} 100% {transform: rotate(15deg);} }

        #status-bar { margin-top: 15px; font-size: 14px; color: #94a3b8; font-weight: bold; letter-spacing: 1px; text-transform: uppercase; height: 20px; }
    </style>
</head>
<body>

    <a href="/tools" class="fixed top-4 left-4 z-50 bg-gray-800/80 hover:bg-gray-700 text-white p-3 rounded-full border border-gray-600 shadow-lg backdrop-blur-sm transition">
        <i class="fas fa-arrow-left"></i>
    </a>

    <div class="text-center mb-4 mt-8">
        <h1 class="text-3xl font-black text-transparent bg-clip-text bg-gradient-to-r from-red-500 via-purple-500 to-cyan-500 tracking-wider" style="filter: drop-shadow(0 0 10px rgba(255,255,255,0.2));">
            NEON LUDO
        </h1>
    </div>

    <div class="ludo-container" id="board-container">
        <div class="ludo-grid" id="grid">
            </div>
    </div>

    <div class="control-panel">
        <div class="player-tag player-red active" id="p-red">
            <i class="fas fa-user-astronaut text-lg block mb-1"></i> SHANTANU
        </div>
        <div class="dice" id="dice" onclick="rollDice()">ðŸŽ²</div>
        <div class="player-tag player-blue" id="p-blue">
            <i class="fas fa-robot text-lg block mb-1"></i> SHANVIKA
        </div>
    </div>
    
    <div id="status-bar">Your Turn! Roll the Dice.</div>

    <script>
        // --- 1. BOARD GENERATION & MAPPING ---
        // 52 Exact Coordinates for the outer Ludo Track (1-based CSS Grid index: [col, row])
        const pathCoords = [
            [7,14], [7,13], [7,12], [7,11], [7,10], // Red start upwards
            [6,9], [5,9], [4,9], [3,9], [2,9], [1,9], // Leftwards
            [1,8], [1,7], // Up
            [2,7], [3,7], [4,7], [5,7], [6,7], // Rightwards
            [7,6], [7,5], [7,4], [7,3], [7,2], [7,1], // Upwards
            [8,1], [9,1], // Right
            [9,2], [9,3], [9,4], [9,5], [9,6], // Blue start downwards
            [10,7], [11,7], [12,7], [13,7], [14,7], [15,7], // Rightwards
            [15,8], [15,9], // Down
            [14,9], [13,9], [12,9], [11,9], [10,9], // Leftwards
            [9,10], [9,11], [9,12], [9,13], [9,14], [9,15], // Downwards
            [8,15] // Left (Back to start)
        ];

        const redHomePath = [[8,14], [8,13], [8,12], [8,11], [8,10], [8,9]]; // Win at index 5
        const blueHomePath = [[8,2], [8,3], [8,4], [8,5], [8,6], [8,7]];

        const safeSpots = [0, 9, 13, 22, 26, 35, 39, 48];

        const grid = document.getElementById('grid');
        let html = '';
        for(let r=1; r<=15; r++) {
            for(let c=1; c<=15; c++) {
                html += `<div class="cell" id="c-${c}-${r}"></div>`;
            }
        }
        
        // Add Homes overlay
        html += `
            <div class="home-red"><div class="home-inner" id="base-red"></div></div>
            <div class="home-blue"><div class="home-inner" id="base-blue"></div></div>
            <div class="home-green"></div><div class="home-yellow"></div>
            <div class="center-home"></div>
        `;
        grid.innerHTML = html;

        // Color Safe Zones & Paths
        safeSpots.forEach(idx => document.getElementById(`c-${pathCoords[idx][0]}-${pathCoords[idx][1]}`).classList.add('safe-zone'));
        redHomePath.slice(0,5).forEach(p => document.getElementById(`c-${p[0]}-${p[1]}`).classList.add('path-red'));
        blueHomePath.slice(0,5).forEach(p => document.getElementById(`c-${p[0]}-${p[1]}`).classList.add('path-blue'));
        document.getElementById(`c-${pathCoords[0][0]}-${pathCoords[0][1]}`).classList.add('path-red');
        document.getElementById(`c-${pathCoords[26][0]}-${pathCoords[26][1]}`).classList.add('path-blue');

        // --- 2. GAME STATE & TOKENS ---
        let turn = 'red'; 
        let currentRoll = 0;
        let gameState = 'WAITING_ROLL'; // WAITING_ROLL, WAITING_MOVE, ANIMATING

        const tokens = {
            red:  [{id:'r1', pos:-1}, {id:'r2', pos:-1}, {id:'r3', pos:-1}, {id:'r4', pos:-1}],
            blue: [{id:'b1', pos:-1}, {id:'b2', pos:-1}, {id:'b3', pos:-1}, {id:'b4', pos:-1}]
        };

        const boardContainer = document.getElementById('board-container');

        // Initialize Base Spots and Gotis in DOM
        ['red', 'blue'].forEach(color => {
            const base = document.getElementById(`base-${color}`);
            tokens[color].forEach((t, i) => {
                base.innerHTML += `<div class="base-spot" id="spot-${t.id}"></div>`;
                const goti = document.createElement('div');
                goti.className = `goti ${color}`;
                goti.id = t.id;
                goti.onclick = () => handleGotiClick(color, t.id);
                boardContainer.appendChild(goti);
            });
        });

        function getCenterPoint(elementId) {
            const el = document.getElementById(elementId);
            if(!el) return {x:0, y:0};
            const rect = el.getBoundingClientRect();
            const boardRect = boardContainer.getBoundingClientRect();
            return {
                x: rect.left - boardRect.left + rect.width / 2,
                y: rect.top - boardRect.top + rect.height / 2
            };
        }

        function drawBoard() {
            // Place every goti physically
            ['red', 'blue'].forEach(color => {
                tokens[color].forEach(t => {
                    const gotiEl = document.getElementById(t.id);
                    gotiEl.classList.remove('active-anim');
                    gotiEl.style.display = 'block';

                    let targetId = '';
                    if(t.pos === -1) {
                        targetId = `spot-${t.id}`;
                    } else if (t.pos >= 100) {
                        let homeIdx = t.pos - 100;
                        if(homeIdx === 5) { gotiEl.style.display = 'none'; return; } // Won
                        let path = color === 'red' ? redHomePath : blueHomePath;
                        targetId = `c-${path[homeIdx][0]}-${path[homeIdx][1]}`;
                    } else {
                        targetId = `c-${pathCoords[t.pos][0]}-${pathCoords[t.pos][1]}`;
                    }

                    const pt = getCenterPoint(targetId);
                    gotiEl.style.left = pt.x + 'px';
                    gotiEl.style.top = pt.y + 'px';
                });
            });

            // Highlight valid moves if user turn
            if(turn === 'red' && gameState === 'WAITING_MOVE') {
                tokens.red.forEach(t => {
                    if(isValidMove(t, currentRoll, 'red')) {
                        document.getElementById(t.id).classList.add('active-anim');
                    }
                });
            }
        }

        setTimeout(drawBoard, 300); // Give CSS grid time to render
        window.addEventListener('resize', drawBoard);

        // --- 3. GAME LOGIC ---
        function setStatus(msg) { document.getElementById('status-bar').innerText = msg; }

        function rollDice() {
            if(turn !== 'red' || gameState !== 'WAITING_ROLL') return;
            executeRoll();
        }

        function executeRoll() {
            gameState = 'ANIMATING';
            const dice = document.getElementById('dice');
            dice.classList.add('rolling');
            setStatus(turn === 'red' ? 'Rolling...' : 'Shanvika is rolling...');

            let rolls = 0;
            let rollInterval = setInterval(() => {
                dice.innerText = Math.floor(Math.random() * 6) + 1;
                rolls++;
                if(rolls > 10) {
                    clearInterval(rollInterval);
                    dice.classList.remove('rolling');
                    currentRoll = Math.floor(Math.random() * 6) + 1;
                    
                    // Hack to make Shanvika smarter (more 6s) - It's AI privilege! ðŸ˜‰
                    if(turn === 'blue' && Math.random() > 0.7) currentRoll = 6; 
                    
                    dice.innerText = currentRoll;
                    checkMoves();
                }
            }, 50);
        }

        function isValidMove(goti, steps, color) {
            if(goti.pos === -1) return steps === 6; // Can only open on 6
            if(goti.pos >= 100) return (goti.pos - 100 + steps) <= 5; // Must land exactly in center
            return true;
        }

        function checkMoves() {
            let validGotis = tokens[turn].filter(t => isValidMove(t, currentRoll, turn));
            
            if(validGotis.length === 0) {
                setStatus(`No valid moves!`);
                setTimeout(nextTurn, 1000);
                return;
            }

            if(turn === 'blue') {
                setStatus(`Shanvika is thinking...`);
                setTimeout(() => doAiMove(validGotis), 1000);
            } else {
                gameState = 'WAITING_MOVE';
                setStatus(`Tap a glowing token to move ${currentRoll} steps.`);
                drawBoard();
            }
        }

        function handleGotiClick(color, id) {
            if(turn !== 'red' || color !== 'red' || gameState !== 'WAITING_MOVE') return;
            let goti = tokens.red.find(t => t.id === id);
            if(!isValidMove(goti, currentRoll, 'red')) return;
            moveTokenProcess(goti, 'red');
        }

        // --- 4. SHANVIKA AI BRAIN ---
        function doAiMove(validGotis) {
            let chosen = validGotis[0];
            
            // AI Prioritization Logic
            // Priority 1: Kill an enemy
            let killGoti = validGotis.find(t => {
                if(t.pos === -1) return false;
                let futurePos = calculateFuturePos(t.pos, currentRoll, 'blue');
                if(futurePos >= 100) return false;
                return isEnemyOnSpot(futurePos, 'red');
            });

            // Priority 2: Win or enter home
            let winGoti = validGotis.find(t => {
                let f = calculateFuturePos(t.pos, currentRoll, 'blue');
                return f === 105; 
            });

            // Priority 3: Open a token
            let openGoti = validGotis.find(t => t.pos === -1 && currentRoll === 6);

            if(killGoti) chosen = killGoti;
            else if(winGoti) chosen = winGoti;
            else if(openGoti) chosen = openGoti;
            else {
                // Otherwise move the one closest to home
                chosen = validGotis.reduce((prev, curr) => (curr.pos > prev.pos ? curr : prev));
            }

            moveTokenProcess(chosen, 'blue');
        }

        // --- 5. MOVEMENT & KILL EXECUTION ---
        function calculateFuturePos(currentPos, steps, color) {
            if(currentPos === -1) return color === 'red' ? 0 : 26;
            let pos = currentPos;
            for(let i=0; i<steps; i++) {
                if(pos >= 100) pos++;
                else {
                    pos++;
                    if(pos > 51) pos = 0;
                    if(color === 'red' && pos === 51) { pos = 100; i++; break; } // Red Entry
                    if(color === 'blue' && pos === 25) { pos = 100; i++; break; } // Blue Entry
                }
            }
            return pos;
        }

        function isEnemyOnSpot(pos, enemyColor) {
            if(safeSpots.includes(pos)) return false; // Safe zone
            return tokens[enemyColor].some(t => t.pos === pos);
        }

        function moveTokenProcess(goti, color) {
            gameState = 'ANIMATING';
            
            if(goti.pos === -1) {
                goti.pos = color === 'red' ? 0 : 26;
            } else {
                goti.pos = calculateFuturePos(goti.pos, currentRoll, color);
            }

            // Check for Kills
            let enemyColor = color === 'red' ? 'blue' : 'red';
            let killed = false;
            
            if(goti.pos >= 0 && goti.pos < 100 && !safeSpots.includes(goti.pos)) {
                tokens[enemyColor].forEach(e => {
                    if(e.pos === goti.pos) {
                        e.pos = -1; // Send back to base
                        killed = true;
                    }
                });
            }

            drawBoard();

            setTimeout(() => {
                // Win check
                if(tokens[color].every(t => t.pos === 105)) {
                    setStatus(color === 'red' ? "ðŸŽ‰ YOU WON THE GAME! ðŸŽ‰" : "ðŸ˜ˆ SHANVIKA WON! BETTER LUCK NEXT TIME!");
                    return;
                }

                if(currentRoll === 6 || killed) {
                    setStatus(killed ? "ðŸŽ¯ EPIC KILL! Roll Again!" : "ðŸŽ² Got a 6! Roll Again!");
                    gameState = 'WAITING_ROLL';
                    if(turn === 'blue') setTimeout(executeRoll, 1000);
                } else {
                    nextTurn();
                }
            }, 500); // Wait for CSS animation
        }

        function nextTurn() {
            turn = turn === 'red' ? 'blue' : 'red';
            document.getElementById('p-red').classList.toggle('active');
            document.getElementById('p-blue').classList.toggle('active');
            document.getElementById('dice').innerText = "ðŸŽ²";
            gameState = 'WAITING_ROLL';
            
            setStatus(turn === 'red' ? "Your Turn! Tap Dice." : "Shanvika is thinking...");
            drawBoard(); // Remove highlights
            
            if(turn === 'blue') setTimeout(executeRoll, 1000);
        }

    </script>
</body>
</html>